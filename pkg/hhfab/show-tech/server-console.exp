#!/usr/bin/env expect
# Copyright 2024 Hedgehog
# SPDX-License-Identifier: Apache-2.0

set force_conservative 1
set timeout 20

if {[llength $argv] < 2} {
    puts "Usage: $argv0 SERVER_NAME OUTPUT_FILE [-v]"
    exit 1
}

set SERVER_NAME [lindex $argv 0]
set OUTPUT_FILE [lindex $argv 1]
set VERBOSE 0

for {set i 2} {$i < [llength $argv]} {incr i} {
    set arg [lindex $argv $i]
    if {$arg eq "-v"} {
        set VERBOSE 1
    }
}

log_file -a $OUTPUT_FILE

puts "== Console diagnostics for $SERVER_NAME =="
if {[info exists env(SERVER_DIAG_REASON)]} {
    puts "Reason: $env(SERVER_DIAG_REASON)"
}
puts "Started at: [clock format [clock seconds]]"

proc log_message {level msg} {
    puts "$level: $msg"
}

# Determine hhfab binary path
if {[info exists env(HHFAB_BIN)]} {
    set HHFAB $env(HHFAB_BIN)
    log_message "EXP-DBG" "Using HHFAB from environment: $HHFAB"
} elseif {[file exists "./hhfab"]} {
    set HHFAB "./hhfab"
    log_message "EXP-DBG" "Using HHFAB from current directory"
} else {
    catch {set HHFAB [exec which hhfab]} result
    if {[string length $result] == 0} {
        puts "Error: hhfab binary not found in HHFAB_BIN, current directory, or PATH."
        exit 2
    }
    set HHFAB $result
    log_message "EXP-DBG" "Using HHFAB from PATH: $HHFAB"
}

if {!([file exists $HHFAB] && [file executable $HHFAB])} {
    log_message "EXP-ERR" "HHFAB does not contain a valid path or is not executable."
    exit 2
}

set cmd "$HHFAB vlab serial -n $SERVER_NAME"
if {$VERBOSE} {
    append cmd " -v"
}
log_message "EXP-DBG" "Spawning: $cmd"

set spawn_result [catch {spawn {*}[split $cmd]} spawn_error]
if {$spawn_result != 0} {
    log_message "EXP-ERR" "$HHFAB failed with: $spawn_error"
    exit 3
}

expect {
    -ex "Type the hot key to suspend the connection: <CTRL>Z" {
        log_message "EXP-DBG" "Connected via serial (type 1)"
        send "\r"
    }
    -ex "Use Ctrl+] to escape, if no output try Enter, safe to use Ctrl+C/Ctrl+Z" {
        log_message "EXP-DBG" "Connected via serial (type 2)"
        send "\r"
    }
    -ex "The connection was unsuccessful" {
        log_message "EXP-ERR" "Connection unsuccessful"
        exit 4
    }
    timeout {
        log_message "EXP-ERR" "Connection to console timed out"
        exit 4
    }
    eof {
        log_message "EXP-ERR" "Connection to console failed (EOF)"
        exit 4
    }
    default {
        log_message "EXP-DBG" "Received unexpected initial output"
        send "\r"
    }
}

set prompt_re {.*[#\$] $}
set logged_in 0
set login_attempts 0
set max_login_attempts 3
set login_done 0

while {!$login_done} {
    expect {
        -re $prompt_re {
            set logged_in 1
            set login_done 1
        }
        -re "(?i)login:" {
            send "core\r"
            exp_continue
        }
        -re "Password:" {
            if {$login_attempts >= $max_login_attempts} {
                log_message "EXP-ERR" "Login failed: max attempts reached"
                set login_done 1
            } else {
                send "\r"
                incr login_attempts
                exp_continue
            }
        }
        -re "Login incorrect" {
            if {$login_attempts >= $max_login_attempts} {
                log_message "EXP-ERR" "Login failed after $login_attempts attempts"
                set login_done 1
            } else {
                exp_continue
            }
        }
        -re "Maximum number of tries exceeded" {
            log_message "EXP-ERR" "Login failed: maximum number of tries exceeded"
            set login_done 1
        }
        timeout {
            log_message "EXP-ERR" "Login to console timed out"
            set login_done 1
        }
        eof {
            log_message "EXP-ERR" "Login to console failed (EOF)"
            set login_done 1
        }
        default {
            log_message "EXP-DBG" "Waiting for login prompt or shell"
            send "\r"
        }
    }
}

proc run_cmd {cmd prompt prompt_timeout} {
    puts ""
    puts ">>> $cmd"
    send -- "$cmd\r"
    expect -timeout $prompt_timeout -re $prompt {
        return
    } timeout {
        puts "WARN: command timed out: $cmd"
    } eof {
        puts "WARN: console closed while running: $cmd"
    }
}

if {$logged_in} {
    run_cmd "ip addr show" $prompt_re 30
    run_cmd "ip link show" $prompt_re 30
    run_cmd "ip route show" $prompt_re 30
    run_cmd "ip neigh show" $prompt_re 30
    run_cmd "networkctl status" $prompt_re 30
    run_cmd "systemctl status sshd --no-pager" $prompt_re 30
    run_cmd "ss -tulnp | grep ':22'" $prompt_re 30
} else {
    log_message "EXP-DBG" "Not logged in; skipping console commands"
}

puts "Finished console capture at: [clock format [clock seconds]]"
exit 0

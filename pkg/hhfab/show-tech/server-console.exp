#!/usr/bin/env expect
# Copyright 2025 Hedgehog
# SPDX-License-Identifier: Apache-2.0

set force_conservative 1
set timeout 20

if {[llength $argv] < 2} {
    puts "Usage: $argv0 SERVER_NAME OUTPUT_FILE [-v]"
    exit 1
}

set SERVER_NAME [lindex $argv 0]
set OUTPUT_FILE [lindex $argv 1]
set VERBOSE 0

for {set i 2} {$i < [llength $argv]} {incr i} {
    set arg [lindex $argv $i]
    if {$arg eq "-v"} {
        set VERBOSE 1
    }
}

log_file -a $OUTPUT_FILE

puts "== Console diagnostics for $SERVER_NAME (server) =="
if {[info exists env(CONSOLE_DIAG_REASON)]} {
    puts "Reason: $env(CONSOLE_DIAG_REASON)"
}
puts "Started at: [clock format [clock seconds]]"

proc log_message {level msg} {
    puts "$level: $msg"
}

# Determine hhfab binary path
if {[info exists env(HHFAB_BIN)]} {
    set HHFAB $env(HHFAB_BIN)
    log_message "EXP-DBG" "Using HHFAB from environment: $HHFAB"
} elseif {[file exists "./hhfab"]} {
    set HHFAB "./hhfab"
    log_message "EXP-DBG" "Using HHFAB from current directory"
} else {
    catch {set HHFAB [exec which hhfab]} result
    if {[string length $result] == 0} {
        puts "Error: hhfab binary not found in HHFAB_BIN, current directory, or PATH."
        exit 2
    }
    set HHFAB $result
    log_message "EXP-DBG" "Using HHFAB from PATH: $HHFAB"
}

if {!([file exists $HHFAB] && [file executable $HHFAB])} {
    log_message "EXP-ERR" "HHFAB does not contain a valid path or is not executable."
    exit 2
}

set cmd "$HHFAB vlab serial -n $SERVER_NAME"
if {$VERBOSE} {
    append cmd " -v"
}
log_message "EXP-DBG" "Spawning: $cmd"

set spawn_result [catch {spawn {*}[split $cmd]} spawn_error]
if {$spawn_result != 0} {
    log_message "EXP-ERR" "$HHFAB failed with: $spawn_error"
    exit 3
}

expect {
    -ex "Type the hot key to suspend the connection: <CTRL>Z" {
        log_message "EXP-DBG" "Connected via serial (type 1)"
        send "\r"
    }
    -ex "Use Ctrl+] to escape, if no output try Enter, safe to use Ctrl+C/Ctrl+Z" {
        log_message "EXP-DBG" "Connected via serial (type 2)"
        send "\r"
    }
    -ex "The connection was unsuccessful" {
        log_message "EXP-ERR" "Connection unsuccessful"
        exit 4
    }
    timeout {
        log_message "EXP-ERR" "Connection to console timed out"
        exit 4
    }
    eof {
        log_message "EXP-ERR" "Connection to console failed (EOF)"
        exit 4
    }
    default {
        log_message "EXP-DBG" "Received unexpected initial output"
        send "\r"
    }
}

set prompt_re {.*[#\$] $}
set logged_in 0
set prompt_timeout 20

# Servers should be auto-logged in, just check for prompt
log_message "EXP-DBG" "Checking for shell prompt"
expect -timeout $prompt_timeout {
    -re $prompt_re {
        set logged_in 1
    }
    -re "(?i)login:" {
        log_message "EXP-DBG" "Unexpected login prompt on server"
    }
    timeout {
        log_message "EXP-DBG" "No prompt detected"
    }
    eof {
        log_message "EXP-ERR" "Console check failed (EOF)"
    }
}

proc run_cmd {cmd prompt prompt_timeout} {
    puts ""
    puts ">>> $cmd"
    send -- "$cmd\r"
    expect -timeout $prompt_timeout -re $prompt {
        return
    } timeout {
        puts "WARN: command timed out: $cmd"
    } eof {
        puts "WARN: console closed while running: $cmd"
    }
}

if {$logged_in} {
    # Basic network diagnostics for test endpoints
    run_cmd "ip addr show" $prompt_re 30
    run_cmd "ip link show" $prompt_re 30
    run_cmd "ip route show" $prompt_re 30
    run_cmd "ip neigh show" $prompt_re 30
    run_cmd "networkctl status" $prompt_re 30

    # SSH diagnostics
    run_cmd "systemctl status sshd --no-pager" $prompt_re 30
    run_cmd "ss -tulnp | grep ':22'" $prompt_re 30
    run_cmd "journalctl -u sshd --no-pager -n 30" $prompt_re 60
} else {
    log_message "EXP-DBG" "No shell prompt; skipping console commands"
}

puts "Finished console capture at: [clock format [clock seconds]]"
exit 0
